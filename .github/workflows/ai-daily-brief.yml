name: AI-Powered Daily Brief (OpenAI)

on:
  schedule:
    # Runs daily at 10:00 UTC (06:00 Puerto Rico time)
    - cron: '0 10 * * *'
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

jobs:
  generate-ai-daily-brief:
    runs-on: ubuntu-latest

    env:
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      NOAA_API_URL: ${{ secrets.NOAA_API_URL }}
      OPENWEATHER_API_KEY: ${{ secrets.OPENWEATHER_API_KEY }}
      ZENQUOTES_API_URL: ${{ secrets.ZENQUOTES_API_URL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Generate Daily Brief with OpenAI (with retries and fallback)
        id: openai
        run: |
          set -euo pipefail

          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "âŒ ERROR: OPENAI_API_KEY is not set."
            exit 1
          fi

          # Create the prompt for OpenAI
          cat > /tmp/prompt.txt << 'PROMPT_EOF'
          You are an AI assistant tasked with generating a comprehensive "Daily Brief" for a GitHub profile README.

          **Your Task:**
          Generate a markdown snippet that will replace the content between `<!-- BEGIN DAILY BRIEF -->` and `<!-- END DAILY BRIEF -->` markers in the README.md file.

          **CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE):**
          - Your ENTIRE output must start with the line:
            <!-- BEGIN DAILY BRIEF -->
          - Your ENTIRE output must end with the line:
            <!-- END DAILY BRIEF -->
          - Between those markers, you MUST:
            - Use literal `<details>` and `<summary>` tags. Do **NOT** use HTML-escaped tags like `&lt;details&gt;` or `&lt;summary&gt;`.
            - Start with a top-level collapsible section:
              ```markdown
              <details>
              <summary><b>ğŸ“° Today's Intelligence Brief</b></summary>
              ```
            - Include a centered header section:
              ```markdown
              <div align="center">

              # ğŸ“… Daily Brief

              **[DayOfWeek, Month DD, YYYY]**

              </div>

              ---
              ```
            - Provide each of the following subsections in its own `<details>` block with a `<summary><b>...</b></summary>`:
              1. ğŸ’­ Quote of the Day
              2. ğŸŒ¤ï¸ Weather Report (including Space Weather status)
              3. ğŸ“° Global Intelligence News
              4. ğŸ” Cyber Pulse Report
              5. ğŸ”¥ Trending on GitHub (with table and chart placeholder)
            - End with a footer:
              ```markdown
              ---
              
              <div align="center">
              
              _Generated at HH:MM AM/PM UTC_
              
              </div>
              ```
            - Close the top-level collapsible with:
              ```markdown
              </details>
              ```

          **Requirements:**

          1. **Structure**: The output must be a collapsible section starting with:
             ```markdown
             <details>
             <summary><b>ğŸ“° Today's Intelligence Brief</b></summary>
             ```

          2. **Header Section** (centered):
             ```markdown
             <div align="center">

             # ğŸ“… Daily Brief

             **[DayOfWeek, Month DD, YYYY]**

             </div>

             ---
             ```

          3. **Subsections** (each in its own collapsible `<details>` block):

             a. **ğŸ’­ Quote of the Day**:
                - Fetch a random inspirational quote
                - Format as a blockquote with author attribution
                - Example format:
                  ```markdown
                  ### ğŸ’­ Quote of the Day

                  > "Quote text here."
                  >
                  > â€” **Author Name**
                  ```

             b. **ğŸŒ¤ï¸ Weather Report**:
                - Location: San Juan, Puerto Rico
                - Current conditions: temperature (Â°F), humidity (%), wind speed (mph)
                - Today's forecast: High/Low temperatures, precipitation
                - Use appropriate weather emoji (â˜€ï¸, â›…, ğŸŒ§ï¸, etc.)

                **Space Weather Status** (within same section):
                - KP Index with status indicator (ğŸŸ¢ Quiet, ğŸŸ¡ Unsettled, ğŸŸ  Active, ğŸ”´ Storm)
                - Recent space weather alerts (if available)

             c. **ğŸ“° Global Intelligence News**:
                - Fetch top 3 world news headlines
                - Provide 1-2 sentence summaries for each
                - If unavailable: "**Intel data unavailable** â›”"

             d. **ğŸ” Cyber Pulse Report**:
                - Fetch top 3 cybersecurity news items
                - Provide 1-2 sentence summaries for each
                - If unavailable: "**CyberPulse data unavailable** â›”"

             e. **ğŸ”¥ Trending on GitHub**:
                - List top 3 trending repositories from past week
                - Use a markdown table with columns: Repo | Author | Description | Language | Stars | Forks | Link
                - Format: Stars with â­ emoji, Forks with ğŸ”± emoji
                - Include a placeholder for trending chart: `![Trending Repos Chart](assets/trending.png)`

          4. **Footer** (centered):
             ```markdown
             ---
             
             <div align="center">
             
             _Generated at HH:MM AM/PM UTC_
             
             </div>
             ```

          5. **Closing tag**:
             ```markdown
             </details>
             ```

          **Important Notes:**
          - Use real-time data where possible, but provide graceful fallbacks if data is unavailable.
          - Maintain the exact format and emoji style shown above.
          - Each subsection should be in a `<details>` block with a `<summary><b>Title</b></summary>` header.
          - Use horizontal rules (`---`) to separate major sections.
          - Output ONLY the content from `<!-- BEGIN DAILY BRIEF -->` to `<!-- END DAILY BRIEF -->` (including these markers).
          - Ensure all markdown is properly formatted and valid.
          - Keep descriptions concise (truncate to ~80 chars if needed).

          PROMPT_EOF

          PROMPT_TEXT=$(cat /tmp/prompt.txt)

          # Prepare base payload
          jq -n \
            --arg model "gpt-4o-mini" \
            --arg system_content "You are an AI assistant generating a Daily Brief for a GitHub profile README. Generate markdown content that strictly follows the given format and markers, using real-time style data where possible." \
            --arg prompt "$PROMPT_TEXT" \
            '{
              "model": $model,
              "messages": [
                {
                  "role": "system",
                  "content": $system_content
                },
                {
                  "role": "user",
                  "content": $prompt
                }
              ],
              "temperature": 0.7,
              "max_tokens": 4000
            }' > /tmp/payload.json

          echo "â„¹ï¸ OpenAI payload prepared (model: gpt-4o-mini)."

          call_openai() {
            local payload_file=$1
            local attempt=$2
            local model_name
            model_name=$(jq -r '.model' "$payload_file" || echo "unknown")
            echo "ğŸš€ Calling OpenAI API (model=${model_name}, attempt=${attempt})..."

            HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/response.json \
              https://api.openai.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer ${OPENAI_API_KEY}" \
              -d @"${payload_file}")

            echo "â„¹ï¸ HTTP Response Code: ${HTTP_CODE}"

            if [ "${HTTP_CODE}" = "200" ]; then
              echo "âœ… OpenAI API call successful (model=${model_name})"
              jq -r '.choices[0].message.content' /tmp/response.json > /tmp/brief.md
              if [ -s /tmp/brief.md ]; then
                echo "âœ… Daily brief content written to /tmp/brief.md"
                return 0
              else
                echo "âŒ ERROR: /tmp/brief.md is empty after successful response."
                cat /tmp/response.json || true
                return 1
              fi
            else
              echo "âŒ ERROR: OpenAI API call failed (model=${model_name}) with HTTP code ${HTTP_CODE}"
              echo "ğŸ” Full response from OpenAI:"
              cat /tmp/response.json || echo "(no response body)"
              return 1
            fi
          }

          # Try primary model with retries (up to 3 attempts)
          MAX_ATTEMPTS=3
          ATTEMPT=1
          PRIMARY_OK=0

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if call_openai /tmp/payload.json "$ATTEMPT"; then
              PRIMARY_OK=1
              break
            fi
            echo "âš ï¸ Primary model attempt ${ATTEMPT} failed."
            ATTEMPT=$((ATTEMPT + 1))
            if [ $ATTEMPT -le $MAX_ATTEMPTS ]; then
              echo "â³ Retrying primary model in 5 seconds..."
              sleep 5
            fi
          done

          if [ $PRIMARY_OK -ne 1 ]; then
            echo "âš ï¸ Primary model gpt-4o-mini failed after ${MAX_ATTEMPTS} attempts. Trying fallback model gpt-4o..."

            jq '.model = "gpt-4o"' /tmp/payload.json > /tmp/payload-fallback.json

            ATTEMPT=1
            FALLBACK_OK=0
            while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
              if call_openai /tmp/payload-fallback.json "$ATTEMPT"; then
                FALLBACK_OK=1
                break
              fi
              echo "âš ï¸ Fallback model attempt ${ATTEMPT} failed."
              ATTEMPT=$((ATTEMPT + 1))
              if [ $ATTEMPT -le $MAX_ATTEMPTS ]; then
                echo "â³ Retrying fallback model in 5 seconds..."
                sleep 5
              fi
            done

            if [ $FALLBACK_OK -ne 1 ]; then
              echo "âŒ ERROR: All attempts (primary and fallback models) failed."
              echo "ğŸ” Showing last OpenAI response:"
              cat /tmp/response.json || echo "(no response body)"
              exit 1
            fi
          fi

          echo "âœ… OpenAI generation step completed."

      - name: Validate generated Daily Brief
        id: validate
        run: |
          set -euo pipefail

          if [ ! -s /tmp/brief.md ]; then
            echo "âŒ Validation failed: /tmp/brief.md is missing or empty."
            exit 1
          fi

          echo "â„¹ï¸ Running Python validation on /tmp/brief.md..."

          python << 'PY'
          import sys
          from pathlib import Path

          brief_path = Path("/tmp/brief.md")
          content = brief_path.read_text(encoding="utf-8")
          lines = content.splitlines()

          def fail(msg: str) -> None:
            print(f"âŒ Validation error: {msg}")
            sys.exit(1)

          # Basic non-empty check already done in shell, but double-check
          if not content.strip():
            fail("/tmp/brief.md is empty after stripping whitespace.")

          # Check markers
          if "<!-- BEGIN DAILY BRIEF -->" not in content:
            fail("Missing opening marker '<!-- BEGIN DAILY BRIEF -->'.")
          if "<!-- END DAILY BRIEF -->" not in content:
            fail("Missing closing marker '<!-- END DAILY BRIEF -->'.")

          if content.strip().splitlines()[0].strip() != "<!-- BEGIN DAILY BRIEF -->":
            fail("Content does not begin exactly with '<!-- BEGIN DAILY BRIEF -->'.")
          if content.strip().splitlines()[-1].strip() != "<!-- END DAILY BRIEF -->":
            fail("Content does not end exactly with '<!-- END DAILY BRIEF -->'.")

          # Must contain a <details> block (literal)
          if "<details>" not in content:
            fail("No literal <details> tag found in content.")
          if "<summary>" not in content:
            fail("No literal <summary> tag found in content.")

          # Disallow HTML-escaped tags
          if "&lt;details&gt;" in content or "&lt;summary&gt;" in content:
            fail("Found HTML-escaped tags (&lt;details&gt; or &lt;summary&gt;). Must use literal tags.")

          # Date header
          if "# ğŸ“… Daily Brief" not in content:
            fail("Missing '# ğŸ“… Daily Brief' header.")

          # Real content: at least > 10 non-empty lines
          non_empty_lines = [ln for ln in lines if ln.strip()]
          if len(non_empty_lines) <= 10:
            fail(f"Not enough non-empty content lines: {len(non_empty_lines)} (need > 10).")

          # Check subsections presence by key phrases
          required_phrases = [
            "ğŸ’­ Quote of the Day",
            "ğŸŒ¤ï¸ Weather Report",
            "ğŸ“° Global Intelligence News",
            "ğŸ” Cyber Pulse Report",
            "ğŸ”¥ Trending on GitHub",
            "![Trending Repos Chart](assets/trending.png)",
          ]
          for phrase in required_phrases:
            if phrase not in content:
              fail(f"Missing required subsection or element containing: {phrase!r}")

          print("âœ… Validation of /tmp/brief.md successful.")
          PY

          echo "âœ… Generated Daily Brief passed validation."

      - name: Update README with Daily Brief via Python
        id: update_readme
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if [ ! -f "README.md" ]; then
            echo "âŒ ERROR: README.md not found!"
            exit 1
          fi

          echo "â„¹ï¸ Updating README.md using Python (no AWK/sed replacement)..."

          python << 'PY'
          import sys
          from pathlib import Path

          readme_path = Path("README.md")
          brief_path = Path("/tmp/brief.md")

          if not readme_path.exists():
            print("âŒ ERROR: README.md not found (inside Python).")
            sys.exit(1)

          brief_content = brief_path.read_text(encoding="utf-8")
          # Normalize to ensure trailing newline on the brief block
          if not brief_content.endswith("\n"):
            brief_content += "\n"

          BEGIN = "<!-- BEGIN DAILY BRIEF -->"
          END = "<!-- END DAILY BRIEF -->"

          readme_text = readme_path.read_text(encoding="utf-8")
          original_text = readme_text  # keep for comparison

          # Normalize newlines to \n
          readme_text = readme_text.replace("\r\n", "\n").replace("\r", "\n")

          begin_index = readme_text.find(BEGIN)
          end_index = readme_text.find(END)

          if begin_index == -1 or end_index == -1:
            print("âš ï¸ Markers not found in README.md. Appending starter block at end.")
            # Ensure README ends with exactly one newline before appending
            stripped = readme_text.rstrip("\n")
            starter = (
                "\n\n"
                "## ğŸ“… Daily Brief\n\n"
                f"{brief_content}"
            )
            new_text = stripped + starter
          else:
            if end_index < begin_index:
              print("âŒ ERROR: END marker appears before BEGIN marker in README.md.")
              sys.exit(1)

            print("âœ… Found existing markers in README.md. Replacing block content.")
            # end_index points to start of END marker; we want to remove from BEGIN
            # through END marker inclusive.
            end_marker_end = end_index + len(END)
            # We also want to include trailing newline(s) after END to avoid duplication.
            # We'll detect newline after END if present.
            while end_marker_end < len(readme_text) and readme_text[end_marker_end] in ("\n", "\r"):
              end_marker_end += 1

            # brief_content already includes markers, per validation.
            new_text = readme_text[:begin_index] + brief_content + readme_text[end_marker_end:]

          # Ensure final README ends with exactly one newline
          new_text = new_text.rstrip("\n") + "\n"

          if new_text == original_text:
            print("â„¹ï¸ README.md content is unchanged after update (idempotent).")
          else:
            print("âœ… README.md content updated with new Daily Brief block.")

          readme_path.write_text(new_text, encoding="utf-8")
          PY

          echo "âœ… README.md update step complete."

      - name: Archive Daily Brief to daily/YYYY-MM-DD.md
        id: archive
        run: |
          set -euo pipefail

          CURRENT_DATE=$(date -u +'%Y-%m-%d')
          CURRENT_ISO=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          CURRENT_HUMAN_DATE=$(date -u +'%A, %B %d, %Y')

          mkdir -p daily

          echo "â„¹ï¸ Archiving Daily Brief for ${CURRENT_DATE} using Python."

          python << 'PY'
          import sys
          from pathlib import Path
          from datetime import datetime, timezone

          BEGIN = "<!-- BEGIN DAILY BRIEF -->"
          END = "<!-- END DAILY BRIEF -->"

          readme_path = Path("README.md")
          if not readme_path.exists():
            print("âŒ ERROR: README.md not found in archive step.")
            sys.exit(1)

          readme_text = readme_path.read_text(encoding="utf-8")
          begin_index = readme_text.find(BEGIN)
          end_index = readme_text.find(END)

          if begin_index == -1 or end_index == -1 or end_index < begin_index:
            print("âŒ ERROR: Could not reliably locate Daily Brief markers in README.md during archive step.")
            sys.exit(1)

          # Extract from BEGIN through END inclusive
          end_marker_end = end_index + len(END)
          # include any trailing newline(s) after END
          while end_marker_end < len(readme_text) and readme_text[end_marker_end] in ("\n", "\r"):
            end_marker_end += 1

          block = readme_text[begin_index:end_marker_end].rstrip("\n") + "\n"

          now = datetime.now(timezone.utc)
          current_date = now.strftime("%Y-%m-%d")
          current_iso = now.strftime("%Y-%m-%dT%H:%M:%SZ")
          human_date = now.strftime("%A, %B %d, %Y")

          archive_dir = Path("daily")
          archive_dir.mkdir(parents=True, exist_ok=True)
          archive_path = archive_dir / f"{current_date}.md"

          frontmatter = (
              f"---\n"
              f"date: {current_date}\n"
              f"title: \"Daily Brief - {human_date}\"\n"
              f"generated: {current_iso}\n"
              f"---\n\n"
          )

          archive_path.write_text(frontmatter + block, encoding="utf-8")

          print(f"âœ… Archive written to {archive_path}")
          PY

          echo "âœ… Archive step completed."

      - name: Commit and push changes if needed
        id: commit
        run: |
          set -euo pipefail

          CURRENT_DATE=$(date -u +'%Y-%m-%d')

          git add README.md daily || true

          if git diff --cached --quiet; then
            echo "â„¹ï¸ No changes to commit (README and archive unchanged)."
            echo "commit_performed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          COMMIT_MESSAGE="ci: update AI-powered Daily Brief for ${CURRENT_DATE} [skip ci]"
          echo "â„¹ï¸ Changes detected. Creating commit: '${COMMIT_MESSAGE}'"
          git commit -m "${COMMIT_MESSAGE}"

          echo "â„¹ï¸ Pushing commit to ${GITHUB_REF_NAME:-${GITHUB_REF}}"
          git push "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" HEAD:"${GITHUB_REF_NAME:-${GITHUB_REF##*/}}"

          echo "âœ… Changes committed and pushed."
          echo "commit_performed=true" >> "$GITHUB_OUTPUT"

      - name: Add Job Summary
        if: always()
        run: |
          set -euo pipefail

          CURRENT_DATE=$(date -u +'%Y-%m-%d')
          CURRENT_TIME=$(date -u +'%H:%M UTC')
          ARCHIVE_PATH="daily/${CURRENT_DATE}.md"

          SUMMARY_STATUS="unknown"
          if [ "${{ job.status }}" = "success" ]; then
            SUMMARY_STATUS="âœ… Success"
          else
            SUMMARY_STATUS="âŒ Failure"
          fi

          COMMIT_PERFORMED="${{ steps.commit.outputs.commit_performed }}"
          if [ -z "${COMMIT_PERFORMED}" ]; then
            COMMIT_PERFORMED="false"
          fi

          {
            echo "## ğŸ¤– AI-Powered Daily Brief Workflow Summary"
            echo ""
            echo "- **Status:** ${SUMMARY_STATUS}"
            echo "- **Date (UTC):** ${CURRENT_DATE}"
            echo "- **Time (UTC):** ${CURRENT_TIME}"
            echo "- **Commit created:** ${COMMIT_PERFORMED}"
            echo "- **Archive path:** \`${ARCHIVE_PATH}\`"
            echo ""
            echo "### Logs & Notes"
            echo "- OpenAI API used with retries and fallback between \`gpt-4o-mini\` and \`gpt-4o\`."
            echo "- Generated brief was validated for markers, structure, and content richness."
            echo "- README was updated via a Python script that safely replaces the Daily Brief block and enforces exact markers."
            echo "- The archive file preserves YAML frontmatter and the original markers and content."
          } >> "$GITHUB_STEP_SUMMARY"
