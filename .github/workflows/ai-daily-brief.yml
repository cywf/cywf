name: AI-Powered Daily Brief (OpenAI)

on:
  schedule:
    # Runs daily at 10:00 UTC (06:00 Puerto Rico time)
    - cron: '0 10 * * *'
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

jobs:
  generate-ai-daily-brief:
    runs-on: ubuntu-latest

    env:
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      NOAA_API_URL: ${{ secrets.NOAA_API_URL }}
      OPENWEATHER_API_KEY: ${{ secrets.OPENWEATHER_API_KEY }}
      ZENQUOTES_API_URL: ${{ secrets.ZENQUOTES_API_URL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Validate Required Secrets
        run: |
          echo "üîç Validating required secrets..."
          
          # Check for OPENAI_API_KEY
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "‚ùå ERROR: OPENAI_API_KEY secret is not set!"
            echo "Please configure the OPENAI_API_KEY secret in repository settings."
            exit 1
          fi
          echo "‚úÖ OPENAI_API_KEY is set"
          
          # Check for GH_TOKEN
          if [ -z "$GH_TOKEN" ]; then
            echo "‚ùå ERROR: GH_TOKEN secret is not set!"
            echo "Please configure the GH_TOKEN secret in repository settings."
            exit 1
          fi
          echo "‚úÖ GH_TOKEN is set"
          
          echo "‚úÖ All required secrets are configured"

      - name: Generate Daily Brief with OpenAI
        run: |
          # Create the prompt for OpenAI
          cat > /tmp/prompt.txt << 'PROMPT_EOF'
          You are an AI assistant tasked with generating a comprehensive "Daily Brief" for a GitHub profile README.
          
          **Your Task:**
          Generate a markdown snippet that will replace the content between `<!-- BEGIN DAILY BRIEF -->` and `<!-- END DAILY BRIEF -->` markers in the README.md file.
          
          **Requirements:**
          
          1. **Structure**: The output must be a collapsible section starting with:
             ```markdown
             <details>
             <summary><b>üì∞ Today's Intelligence Brief</b></summary>
             ```
             
          2. **Header Section** (centered):
             ```markdown
             <div align="center">
             
             # üìÖ Daily Brief
             
             **[DayOfWeek, Month DD, YYYY]**
             
             </div>
             
             ---
             ```
          
          3. **Subsections** (each in its own collapsible `<details>` block):
          
             a. **üí≠ Quote of the Day**:
                - Fetch a random inspirational quote
                - Format as a blockquote with author attribution
                - Example format:
                  ```markdown
                  ### üí≠ Quote of the Day
                  
                  > "Quote text here."
                  >
                  > ‚Äî **Author Name**
                  ```
             
             b. **üå§Ô∏è Weather Report**:
                - Location: San Juan, Puerto Rico
                - Current conditions: temperature (¬∞F), humidity (%), wind speed (mph)
                - Today's forecast: High/Low temperatures, precipitation
                - Use appropriate weather emoji (‚òÄÔ∏è, ‚õÖ, üåßÔ∏è, etc.)
                
                **Space Weather Status** (within same section):
                - KP Index with status indicator (üü¢ Quiet, üü° Unsettled, üü† Active, üî¥ Storm)
                - Recent space weather alerts (if available)
             
             c. **üì∞ Global Intelligence News**:
                - Fetch top 3 world news headlines
                - Provide 1-2 sentence summaries for each
                - If unavailable: "**Intel data unavailable** ‚õî"
             
             d. **üîê Cyber Pulse Report**:
                - Fetch top 3 cybersecurity news items
                - Provide 1-2 sentence summaries for each
                - If unavailable: "**CyberPulse data unavailable** ‚õî"
             
             e. **üî• Trending on GitHub**:
                - List top 3 trending repositories from past week
                - Use a markdown table with columns: Repo | Author | Description | Language | Stars | Forks | Link
                - Format: Stars with ‚≠ê emoji, Forks with üî± emoji
                - Include a placeholder for trending chart: `![Trending Repos Chart](assets/trending.png)`
          
          4. **Footer** (centered):
             ```markdown
             ---
             
             <div align="center">
             
             _Generated at HH:MM AM/PM UTC_
             
             </div>
             ```
          
          5. **Closing tag**:
             ```markdown
             </details>
             ```
          
          **Important Notes:**
          - Use real-time data where possible, but provide graceful fallbacks if data is unavailable
          - Maintain the exact format and emoji style shown above
          - Each subsection should be in a `<details>` block with a `<summary><b>Title</b></summary>` header
          - Use horizontal rules (`---`) to separate major sections
          - Output ONLY the content from `<!-- BEGIN DAILY BRIEF -->` to `<!-- END DAILY BRIEF -->` (including these markers)
          - Ensure all markdown is properly formatted and valid
          - Keep descriptions concise (truncate to ~80 chars if needed)
          
          **Data Sources (suggestions if you can access them):**
          - Quotes: Use a variety of inspirational, philosophical, or motivational quotes
          - Weather: OpenMeteo API or similar (coordinates: 18.4655, -66.1057 for San Juan)
          - Space Weather: NOAA SWPC data
          - News: Reuters, AP News, BBC World News
          - Cybersecurity: Recent security bulletins, breaches, or vulnerability announcements
          - GitHub Trending: GitHub trending API or scraping (filter by stars gained in past week)
          
          Please generate the complete daily brief section now, including all markers and properly formatted markdown.
          PROMPT_EOF

          # Read the prompt
          PROMPT_TEXT=$(cat /tmp/prompt.txt)
          
          # Create JSON payload using jq for safe string handling
          jq -n \
            --arg model "gpt-4o-mini" \
            --arg system_content "You are an AI assistant generating a Daily Brief for a GitHub profile README. Generate markdown content that is well-formatted and includes real-time data where possible." \
            --arg prompt "$PROMPT_TEXT" \
            '{
              "model": $model,
              "messages": [
                {
                  "role": "system",
                  "content": $system_content
                },
                {
                  "role": "user",
                  "content": $prompt
                }
              ],
              "temperature": 0.7,
              "max_tokens": 4000
            }' > /tmp/payload.json

          echo "üöÄ Calling OpenAI API..."
          
          # Call OpenAI API
          HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/response.json \
            https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @/tmp/payload.json)
          
          echo "HTTP Response Code: ${HTTP_CODE}"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ OpenAI API call successful"
            
            # Extract the generated content
            jq -r '.choices[0].message.content' /tmp/response.json > /tmp/brief.md
            
            # Check if the brief was generated successfully
            if [ -s /tmp/brief.md ]; then
              echo "‚úÖ Daily brief generated successfully"
              cat /tmp/brief.md
            else
              echo "‚ùå ERROR: Brief file is empty"
              exit 1
            fi
          else
            echo "‚ùå ERROR: OpenAI API call failed with HTTP code ${HTTP_CODE}"
            
            # Check if it's a model availability issue (OpenAI returns 400 or 404 for model errors)
            if [ "$HTTP_CODE" = "404" ] || [ "$HTTP_CODE" = "400" ] || \
               grep -q "model.*not.*found\|model_not_found" /tmp/response.json 2>/dev/null; then
              echo "‚ö†Ô∏è Trying fallback to gpt-4o..."
              
              # Update payload to use gpt-4o
              jq '.model = "gpt-4o"' /tmp/payload.json > /tmp/payload-fallback.json
              
              HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/response.json \
                https://api.openai.com/v1/chat/completions \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -d @/tmp/payload-fallback.json)
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "‚úÖ Fallback to gpt-4o successful"
                jq -r '.choices[0].message.content' /tmp/response.json > /tmp/brief.md
              else
                echo "‚ùå ERROR: Fallback also failed with HTTP code ${HTTP_CODE}"
                cat /tmp/response.json
                exit 1
              fi
            else
              cat /tmp/response.json
              exit 1
            fi
          fi

      - name: Update README with OpenAI Output
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          CURRENT_DATE=$(date -u +'%Y-%m-%d')
          CURRENT_TIME=$(date -u +'%H:%M UTC')
          
          if [ ! -f "README.md" ]; then
            echo "‚ùå ERROR: README.md not found!"
            exit 1
          fi
          
          # Validate that the generated brief is non-empty and valid
          if [ ! -s "/tmp/brief.md" ]; then
            echo "‚ùå ERROR: Generated brief is empty!"
            exit 1
          fi
          
          echo "üìã Validating generated content..."
          BRIEF_SIZE=$(wc -c < /tmp/brief.md)
          echo "‚úÖ Brief size: ${BRIEF_SIZE} bytes"
          
          if [ "${BRIEF_SIZE}" -lt 100 ]; then
            echo "‚ö†Ô∏è WARNING: Generated brief seems too small (< 100 bytes)"
            echo "Content:"
            cat /tmp/brief.md
          fi
          
          # Check if markers exist, if not, create them
          if ! grep -q "<!-- BEGIN DAILY BRIEF -->" README.md || ! grep -q "<!-- END DAILY BRIEF -->" README.md; then
            echo "‚ö†Ô∏è WARNING: Daily brief markers not found in README.md"
            echo "üìù Auto-creating markers at the end of README.md..."
            
            # Append markers to the end of README.md
            cat >> README.md << 'EOF'

## üìÖ Daily Brief

<!-- BEGIN DAILY BRIEF -->
<details>
<summary><b>üì∞ Today's Intelligence Brief</b></summary>

Daily Brief content will be inserted here automatically.

</details>
<!-- END DAILY BRIEF -->

---
EOF
            echo "‚úÖ Markers created successfully"
          fi
          
          # Use Python for reliable text replacement
          # This approach is more predictable than AWK with multiline variables
          python3 << 'PYTHON_EOF'
import sys
import re

# Read the generated brief
with open('/tmp/brief.md', 'r', encoding='utf-8') as f:
    brief_content = f.read().strip()

# Read the current README
with open('README.md', 'r', encoding='utf-8') as f:
    readme_content = f.read()

# Check if the generated content includes markers
has_markers = '<!-- BEGIN DAILY BRIEF -->' in brief_content and '<!-- END DAILY BRIEF -->' in brief_content

if has_markers:
    # Content includes markers - extract content between markers
    print("‚úÖ Content includes markers, extracting inner content only")
    match = re.search(r'<!-- BEGIN DAILY BRIEF -->(.*?)<!-- END DAILY BRIEF -->', brief_content, re.DOTALL)
    if match:
        inner_content = match.group(1).strip()
    else:
        print("‚ö†Ô∏è WARNING: Could not extract content between markers, using full content")
        inner_content = brief_content
else:
    # Content doesn't include markers
    print("‚úÖ Content doesn't include markers, will wrap it")
    inner_content = brief_content

# Replace content between markers in README
# Pattern: match everything from BEGIN to END marker (inclusive)
pattern = r'<!-- BEGIN DAILY BRIEF -->.*?<!-- END DAILY BRIEF -->'

# Replacement: markers with new content in between
replacement = f'<!-- BEGIN DAILY BRIEF -->\n{inner_content}\n<!-- END DAILY BRIEF -->'

# Perform replacement
new_readme = re.sub(pattern, replacement, readme_content, flags=re.DOTALL)

# Verify that replacement occurred
if new_readme == readme_content:
    print("‚ö†Ô∏è WARNING: README content unchanged - replacement may have failed")
    sys.exit(1)

# Write the updated README
with open('README.md', 'w', encoding='utf-8') as f:
    f.write(new_readme)

print("‚úÖ README.md updated successfully")
PYTHON_EOF
          
          if [ $? -ne 0 ]; then
            echo "‚ùå ERROR: Python replacement script failed"
            exit 1
          fi
          
          mkdir -p daily
          
          # Save the daily archive
          sed -n '/<!-- BEGIN DAILY BRIEF -->/,/<!-- END DAILY BRIEF -->/p' README.md > "daily/${CURRENT_DATE}.md"
          
          {
            echo "---"
            echo "date: ${CURRENT_DATE}"
            echo "title: \"Daily Brief - $(date -u +'%A, %B %d, %Y')\""
            echo "generated: $(date -u +'%Y-%m-%dT%H:%M:%S')Z"
            echo "---"
            echo ""
            cat "daily/${CURRENT_DATE}.md"
          } > "daily/${CURRENT_DATE}.tmp.md"
          mv "daily/${CURRENT_DATE}.tmp.md" "daily/${CURRENT_DATE}.md"
          
          git add README.md "daily/${CURRENT_DATE}.md"
          
          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è No changes to commit"
            exit 0
          fi
          
          git commit -m "ci: update AI-powered Daily Brief for ${CURRENT_DATE} [skip ci]"
          git push https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }} HEAD:${{ github.ref_name }}
          
          echo "‚úÖ Daily brief updated and pushed successfully!"

      - name: Add Job Summary
        if: always()
        run: |
          CURRENT_DATE=$(date -u +'%Y-%m-%d')
          CURRENT_TIME=$(date -u +'%H:%M UTC')
          
          {
            echo "## ü§ñ AI-Powered Daily Brief Generated"
            echo ""
            echo "**Date:** ${CURRENT_DATE}"
            echo "**Time:** ${CURRENT_TIME}"
            echo ""
            echo "‚úÖ Daily brief has been generated by OpenAI GPT-4o-mini and committed."
            echo ""
            echo "üìÅ Archive: \`daily/${CURRENT_DATE}.md\`"
            echo ""
            echo "üîó View the updated README: [README.md](../blob/main/README.md)"
          } >> $GITHUB_STEP_SUMMARY
