name: AI-Powered Daily Brief (OpenAI)

on:
  schedule:
    # Runs daily at 10:00 UTC (06:00 Puerto Rico time)
    - cron: '0 10 * * *'
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

jobs:
  generate-ai-daily-brief:
    runs-on: ubuntu-latest

    env:
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      NOAA_API_URL: ${{ secrets.NOAA_API_URL }}
      OPENWEATHER_API_KEY: ${{ secrets.OPENWEATHER_API_KEY }}
      ZENQUOTES_API_URL: ${{ secrets.ZENQUOTES_API_URL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Generate Daily Brief with OpenAI
        run: |
          # Create the prompt for OpenAI
          cat > /tmp/prompt.txt << 'PROMPT_EOF'
          You are an AI assistant tasked with generating a comprehensive "Daily Brief" for a GitHub profile README.
          
          **Your Task:**
          Generate a markdown snippet that will replace the content between `<!-- BEGIN DAILY BRIEF -->` and `<!-- END DAILY BRIEF -->` markers in the README.md file.
          
          **Requirements:**
          
          1. **Structure**: The output must be a collapsible section starting with:
             ```markdown
             <details>
             <summary><b>ğŸ“° Today's Intelligence Brief</b></summary>
             ```
             
          2. **Header Section** (centered):
             ```markdown
             <div align="center">
             
             # ğŸ“… Daily Brief
             
             **[DayOfWeek, Month DD, YYYY]**
             
             </div>
             
             ---
             ```
          
          3. **Subsections** (each in its own collapsible `<details>` block):
          
             a. **ğŸ’­ Quote of the Day**:
                - Fetch a random inspirational quote
                - Format as a blockquote with author attribution
                - Example format:
                  ```markdown
                  ### ğŸ’­ Quote of the Day
                  
                  > "Quote text here."
                  >
                  > â€” **Author Name**
                  ```
             
             b. **ğŸŒ¤ï¸ Weather Report**:
                - Location: San Juan, Puerto Rico
                - Current conditions: temperature (Â°F), humidity (%), wind speed (mph)
                - Today's forecast: High/Low temperatures, precipitation
                - Use appropriate weather emoji (â˜€ï¸, â›…, ğŸŒ§ï¸, etc.)
                
                **Space Weather Status** (within same section):
                - KP Index with status indicator (ğŸŸ¢ Quiet, ğŸŸ¡ Unsettled, ğŸŸ  Active, ğŸ”´ Storm)
                - Recent space weather alerts (if available)
             
             c. **ğŸ“° Global Intelligence News**:
                - Fetch top 3 world news headlines
                - Provide 1-2 sentence summaries for each
                - If unavailable: "**Intel data unavailable** â›”"
             
             d. **ğŸ” Cyber Pulse Report**:
                - Fetch top 3 cybersecurity news items
                - Provide 1-2 sentence summaries for each
                - If unavailable: "**CyberPulse data unavailable** â›”"
             
             e. **ğŸ”¥ Trending on GitHub**:
                - List top 3 trending repositories from past week
                - Use a markdown table with columns: Repo | Author | Description | Language | Stars | Forks | Link
                - Format: Stars with â­ emoji, Forks with ğŸ”± emoji
                - Include a placeholder for trending chart: `![Trending Repos Chart](assets/trending.png)`
          
          4. **Footer** (centered):
             ```markdown
             ---
             
             <div align="center">
             
             _Generated at HH:MM AM/PM UTC_
             
             </div>
             ```
          
          5. **Closing tag**:
             ```markdown
             </details>
             ```
          
          **Important Notes:**
          - Use real-time data where possible, but provide graceful fallbacks if data is unavailable
          - Maintain the exact format and emoji style shown above
          - Each subsection should be in a `<details>` block with a `<summary><b>Title</b></summary>` header
          - Use horizontal rules (`---`) to separate major sections
          - Output ONLY the content from `<!-- BEGIN DAILY BRIEF -->` to `<!-- END DAILY BRIEF -->` (including these markers)
          - Ensure all markdown is properly formatted and valid
          - Keep descriptions concise (truncate to ~80 chars if needed)
          
          **Data Sources (suggestions if you can access them):**
          - Quotes: Use a variety of inspirational, philosophical, or motivational quotes
          - Weather: OpenMeteo API or similar (coordinates: 18.4655, -66.1057 for San Juan)
          - Space Weather: NOAA SWPC data
          - News: Reuters, AP News, BBC World News
          - Cybersecurity: Recent security bulletins, breaches, or vulnerability announcements
          - GitHub Trending: GitHub trending API or scraping (filter by stars gained in past week)
          
          Please generate the complete daily brief section now, including all markers and properly formatted markdown.
          PROMPT_EOF

          # Read the prompt
          PROMPT_TEXT=$(cat /tmp/prompt.txt)
          
          # Create JSON payload using jq for safe string handling
          jq -n \
            --arg model "gpt-4o-mini" \
            --arg system_content "You are an AI assistant generating a Daily Brief for a GitHub profile README. Generate markdown content that is well-formatted and includes real-time data where possible." \
            --arg prompt "$PROMPT_TEXT" \
            '{
              "model": $model,
              "messages": [
                {
                  "role": "system",
                  "content": $system_content
                },
                {
                  "role": "user",
                  "content": $prompt
                }
              ],
              "temperature": 0.7,
              "max_tokens": 4000
            }' > /tmp/payload.json

          echo "ğŸš€ Calling OpenAI API..."
          
          # Call OpenAI API
          HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/response.json \
            https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @/tmp/payload.json)
          
          echo "HTTP Response Code: ${HTTP_CODE}"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… OpenAI API call successful"
            
            # Extract the generated content
            jq -r '.choices[0].message.content' /tmp/response.json > /tmp/brief.md
            
            # Check if the brief was generated successfully
            if [ -s /tmp/brief.md ]; then
              echo "âœ… Daily brief generated successfully"
              cat /tmp/brief.md
            else
              echo "âŒ ERROR: Brief file is empty"
              exit 1
            fi
          else
            echo "âŒ ERROR: OpenAI API call failed with HTTP code ${HTTP_CODE}"
            
            # Check if it's a model availability issue (OpenAI returns 400 or 404 for model errors)
            if [ "$HTTP_CODE" = "404" ] || [ "$HTTP_CODE" = "400" ] || \
               grep -q "model.*not.*found\|model_not_found" /tmp/response.json 2>/dev/null; then
              echo "âš ï¸ Trying fallback to gpt-4o..."
              
              # Update payload to use gpt-4o
              jq '.model = "gpt-4o"' /tmp/payload.json > /tmp/payload-fallback.json
              
              HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/response.json \
                https://api.openai.com/v1/chat/completions \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -d @/tmp/payload-fallback.json)
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "âœ… Fallback to gpt-4o successful"
                jq -r '.choices[0].message.content' /tmp/response.json > /tmp/brief.md
              else
                echo "âŒ ERROR: Fallback also failed with HTTP code ${HTTP_CODE}"
                cat /tmp/response.json
                exit 1
              fi
            else
              cat /tmp/response.json
              exit 1
            fi
          fi

      - name: Validate OpenAI Response
        run: |
          echo "ğŸ” Validating generated Daily Brief content..."
          
          python3 << 'VALIDATION_EOF'
          import sys
          import re
          
          def validate_brief(filepath):
              """Validate the generated brief content before inserting into README"""
              
              print(f"ğŸ“‚ Reading file: {filepath}")
              
              try:
                  with open(filepath, 'r', encoding='utf-8') as f:
                      content = f.read()
              except FileNotFoundError:
                  print(f"âŒ VALIDATION FAILED: File '{filepath}' not found")
                  return False
              except Exception as e:
                  print(f"âŒ VALIDATION FAILED: Error reading file: {e}")
                  return False
              
              # Check 1: File is not empty
              if not content or len(content.strip()) == 0:
                  print("âŒ VALIDATION FAILED: Brief file is empty")
                  return False
              print("âœ… Check 1: File is not empty")
              
              # Check 2: Contains <details> block
              if '<details>' not in content:
                  print("âŒ VALIDATION FAILED: Missing <details> block")
                  return False
              print("âœ… Check 2: Contains <details> block")
              
              # Check 3: Contains date header
              if '# ğŸ“… Daily Brief' not in content and 'ğŸ“… Daily Brief' not in content:
                  print("âŒ VALIDATION FAILED: Missing date header (# ğŸ“… Daily Brief)")
                  return False
              print("âœ… Check 3: Contains date header")
              
              # Check 4: Has real content (more than 10 non-empty lines)
              non_empty_lines = [line for line in content.split('\n') if line.strip()]
              if len(non_empty_lines) < 10:
                  print(f"âŒ VALIDATION FAILED: Insufficient content ({len(non_empty_lines)} non-empty lines, need at least 10)")
                  return False
              print(f"âœ… Check 4: Has sufficient content ({len(non_empty_lines)} non-empty lines)")
              
              # Check 5: Includes both markers
              if '<!-- BEGIN DAILY BRIEF -->' not in content:
                  print("âŒ VALIDATION FAILED: Missing <!-- BEGIN DAILY BRIEF --> marker")
                  return False
              if '<!-- END DAILY BRIEF -->' not in content:
                  print("âŒ VALIDATION FAILED: Missing <!-- END DAILY BRIEF --> marker")
                  return False
              print("âœ… Check 5: Both markers present")
              
              # Check 6: Uses literal HTML tags (not escaped)
              if '&lt;details&gt;' in content or '&lt;summary&gt;' in content:
                  print("âŒ VALIDATION FAILED: HTML tags are escaped (found &lt;details&gt; or &lt;summary&gt;)")
                  return False
              print("âœ… Check 6: HTML tags are not escaped")
              
              # Additional check: Verify markers are in correct order
              begin_pos = content.find('<!-- BEGIN DAILY BRIEF -->')
              end_pos = content.find('<!-- END DAILY BRIEF -->')
              if begin_pos >= end_pos:
                  print("âŒ VALIDATION FAILED: Markers are in wrong order or overlapping")
                  return False
              print("âœ… Check 7: Markers are in correct order")
              
              print("\nğŸ‰ All validation checks passed!")
              return True
          
          if __name__ == '__main__':
              if not validate_brief('/tmp/brief.md'):
                  print("\nâ›” Validation failed. README.md will NOT be modified.")
                  sys.exit(1)
          VALIDATION_EOF
          
          echo "âœ… Validation complete"

      - name: Update README with Python Script
        run: |
          echo "ğŸ“ Updating README.md with validated content..."
          
          python3 << 'UPDATE_EOF'
          import sys
          import re
          
          def update_readme(readme_path, brief_path):
              """Update README.md with the daily brief content using Python"""
              
              # Read the generated brief
              print(f"ğŸ“‚ Reading brief from: {brief_path}")
              try:
                  with open(brief_path, 'r', encoding='utf-8') as f:
                      brief_content = f.read()
              except Exception as e:
                  print(f"âŒ ERROR: Failed to read brief file: {e}")
                  return False
              
              # Read the README
              print(f"ğŸ“‚ Reading README from: {readme_path}")
              try:
                  with open(readme_path, 'r', encoding='utf-8') as f:
                      readme_content = f.read()
              except Exception as e:
                  print(f"âŒ ERROR: Failed to read README: {e}")
                  return False
              
              begin_marker = '<!-- BEGIN DAILY BRIEF -->'
              end_marker = '<!-- END DAILY BRIEF -->'
              
              # Check if markers exist
              begin_pos = readme_content.find(begin_marker)
              end_pos = readme_content.find(end_marker)
              
              if begin_pos == -1 or end_pos == -1:
                  print("âš ï¸  Markers not found in README. Creating new section...")
                  
                  # Create a new daily brief section with markers
                  starter_block = f"\n\n## ğŸ“… Daily Brief\n\n{brief_content}\n\n---\n"
                  
                  # Ensure README ends with exactly one newline
                  readme_content = readme_content.rstrip('\n') + '\n'
                  
                  # Append the starter block
                  new_readme = readme_content + starter_block
                  
                  print("âœ… Starter block with markers appended to README")
              else:
                  print("âœ… Markers found in README")
                  print(f"   BEGIN marker at position: {begin_pos}")
                  print(f"   END marker at position: {end_pos}")
                  
                  # Extract the brief content (with markers) from the generated file
                  # This should already include the markers based on validation
                  
                  # Replace everything between and including markers
                  before_section = readme_content[:begin_pos]
                  after_section = readme_content[end_pos + len(end_marker):]
                  
                  # Insert new content (which includes the markers)
                  new_readme = before_section + brief_content + after_section
                  
                  print("âœ… Content between markers replaced")
              
              # Ensure file ends with exactly one newline
              new_readme = new_readme.rstrip('\n') + '\n'
              
              # Write updated README
              try:
                  with open(readme_path, 'w', encoding='utf-8') as f:
                      f.write(new_readme)
                  print(f"âœ… README.md updated successfully")
                  return True
              except Exception as e:
                  print(f"âŒ ERROR: Failed to write README: {e}")
                  return False
          
          if __name__ == '__main__':
              if not update_readme('README.md', '/tmp/brief.md'):
                  print("\nâ›” Failed to update README.md")
                  sys.exit(1)
          UPDATE_EOF
          
          echo "âœ… README.md update complete"

      - name: Create Daily Archive
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          CURRENT_DATE=$(date -u +'%Y-%m-%d')
          CURRENT_TIME=$(date -u +'%H:%M UTC')
          
          echo "ğŸ“ Creating daily archive..."
          
          mkdir -p daily
          
          # Use Python to extract content between markers for archive
          python3 << 'ARCHIVE_EOF'
          import sys
          import os
          from datetime import datetime, timezone
          
          def create_archive(readme_path, archive_dir):
              """Extract daily brief section and create archive with front matter"""
              
              # Read README
              try:
                  with open(readme_path, 'r', encoding='utf-8') as f:
                      content = f.read()
              except Exception as e:
                  print(f"âŒ ERROR: Failed to read README: {e}")
                  return False
              
              # Extract content between markers (inclusive)
              begin_marker = '<!-- BEGIN DAILY BRIEF -->'
              end_marker = '<!-- END DAILY BRIEF -->'
              
              begin_pos = content.find(begin_marker)
              end_pos = content.find(end_marker)
              
              if begin_pos == -1 or end_pos == -1:
                  print("âŒ ERROR: Markers not found in README")
                  return False
              
              # Extract the section (including markers)
              brief_section = content[begin_pos:end_pos + len(end_marker)]
              
              # Create archive file with front matter
              current_date = datetime.now(timezone.utc)
              date_str = current_date.strftime('%Y-%m-%d')
              date_long = current_date.strftime('%A, %B %d, %Y')
              timestamp = current_date.strftime('%Y-%m-%dT%H:%M:%S') + 'Z'
              
              front_matter = f"""---
          date: {date_str}
          title: "Daily Brief - {date_long}"
          generated: {timestamp}
          ---
          
          """
              
              archive_content = front_matter + brief_section
              
              # Write archive file
              archive_path = os.path.join(archive_dir, f"{date_str}.md")
              try:
                  with open(archive_path, 'w', encoding='utf-8') as f:
                      f.write(archive_content)
                  print(f"âœ… Archive created: {archive_path}")
                  return True
              except Exception as e:
                  print(f"âŒ ERROR: Failed to write archive: {e}")
                  return False
          
          if __name__ == '__main__':
              if not create_archive('README.md', 'daily'):
                  sys.exit(1)
          ARCHIVE_EOF
          
          CURRENT_DATE=$(date -u +'%Y-%m-%d')
          
          git add README.md "daily/${CURRENT_DATE}.md"
          
          if git diff --cached --quiet; then
            echo "â„¹ï¸ No changes to commit"
            exit 0
          fi
          
          git commit -m "ci: update AI-powered Daily Brief for ${CURRENT_DATE} [skip ci]"
          git push https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }} HEAD:${{ github.ref_name }}
          
          echo "âœ… Daily brief updated and pushed successfully!"

      - name: Add Job Summary
        if: always()
        run: |
          CURRENT_DATE=$(date -u +'%Y-%m-%d')
          CURRENT_TIME=$(date -u +'%H:%M UTC')
          
          {
            echo "## ğŸ¤– AI-Powered Daily Brief Generated"
            echo ""
            echo "**Date:** ${CURRENT_DATE}"
            echo "**Time:** ${CURRENT_TIME}"
            echo ""
            echo "âœ… Daily brief has been generated by OpenAI GPT-4o-mini and committed."
            echo ""
            echo "ğŸ“ Archive: \`daily/${CURRENT_DATE}.md\`"
            echo ""
            echo "ğŸ”— View the updated README: [README.md](../blob/main/README.md)"
          } >> $GITHUB_STEP_SUMMARY
